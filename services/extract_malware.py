import re
import spacy
import json

# Load the spaCy NLP model
nlp = spacy.load('en_core_web_sm')

def extract_malware_details(report_text):
    # Regular expressions for extracting hash values
    sha1_regex = r'\b[a-f0-9]{40}\b'
    sha256_regex = r'\b[a-f0-9]{64}\b'
    md5_regex = r'\b[a-f0-9]{32}\b'
    ssdeep_regex = r'\b[0-9]+:[A-F0-9]+\b'  # SSDeep hash pattern
    tlsh_regex = r'\b[0-9A-F]{32}\b'  # TLSH hash pattern

    # Search for all relevant fields (hash values)
    sha1_matches = re.findall(sha1_regex, report_text)
    sha256_matches = re.findall(sha256_regex, report_text)
    md5_matches = re.findall(md5_regex, report_text)
    ssdeep_matches = re.findall(ssdeep_regex, report_text)
    tlsh_matches = re.findall(tlsh_regex, report_text)

    # Use spaCy NLP to extract entities for malware name and type
    doc = nlp(report_text)
    malware_name = 'Not available'
    malware_family = 'Not available'
    malware_type = 'Not available'

    # **Pattern Matching for Malware Families**
    malware_family_patterns = [
        r'\b([A-Za-z0-9]+(?:\s[a-zA-Z0-9]+)*\sfamily)\b', # Matches "XYZ family" or "XYZ malware family"
        r'\b([A-Za-z0-9]+(?:\s[a-zA-Z0-9]+)*\svariant)\b', # Matches "XYZ variant" or "XYZ malware variant"
        r'\b([A-Za-z0-9]+(?:\s[a-zA-Z0-9]+)*\smalware)\b', # Matches "XYZ malware"
        r'\b([A-Za-z0-9]+(?:\s[a-zA-Z0-9]+)*\strojans?\b)',  # Matches "XYZ Trojan" or "XYZ Trojan horse"
    ]
    
    for pattern in malware_family_patterns:
        matches = re.findall(pattern, report_text)
        if matches:
            malware_name = matches[0]
            break

    # **Pattern Matching for Malware Types**
    malware_type_patterns = [
        r'\bis\s[a-zA-Z]+(?:\s[a-zA-Z]+)*\stype\sof\b', 
        r'\bknown\sas\s[a-zA-Z]+(?:\s[a-zA-Z]+)*\b', 
        r'\bis\sa\sform\sof\b',
        r'\bclassified\sas\s[a-zA-Z]+(?:\s[a-zA-Z]+)*\b'
    ]

    for pattern in malware_type_patterns:
        matches = re.findall(pattern, report_text)
        if matches:
            # Extract the type name after the pattern (i.e., the malware type itself)
            type_found = re.search(r'\s([a-zA-Z]+(?:\s[a-zA-Z]+)*)\b', matches[0])
            if type_found:
                malware_type = type_found.group(1).capitalize()
                break

    # **Extract Tags from the Report**
    tag_patterns = [
        r'\b(Reverse Shell|Remote Template Injection|Spear-phishing|DLL|Trojan|Worm|Virus|Ransomware|Spyware|Adware|Rootkit|Keylogger|Backdoor|Botnet|Cryptojacking Malware|Fileless Malware|Logic Bomb|Rogue Security Software|Phishing Malware|Banking Trojan|Remote Access Trojan \(RAT\)|Malvertising|Downloader Malware|Stealer Malware|SQL Injection|Command Injection|Cross-Site Scripting \(XSS\)|Privilege Escalation|Buffer Overflow|Zero-Day Exploit|Man-in-the-Middle \(MitM\)|Brute Force Attack|Credential Stuffing|Watering Hole Attack|Drive-by Download|Session Hijacking|Code Execution|Malvertising|Social Engineering|Exploit Kit|DNS Spoofing|Denial-of-Service \(DoS\)|Distributed Denial-of-Service \(DDoS\)|Path Traversal|Insider Threat|Cryptographic Attacks|Payload Delivery|Data Exfiltration|Network Sniffing|Memory Corruption|Packet Spoofing|ARP Spoofing)\b'
    ]
    
    # Extract tags using the defined patterns
    tags = []
    for pattern in tag_patterns:
        matches = re.findall(pattern, report_text)
        if matches:
            tags.extend(matches)

    # Create metadata dictionary to hold all relevant details
    metadata = {
        'Malware Name': malware_name,
        'Malware Family': malware_family,
        'SHA1': sha1_matches if sha1_matches else 'Not available',
        'SHA256': sha256_matches if sha256_matches else 'Not available',
        'MD5': md5_matches if md5_matches else 'Not available',
        'SSDeep': ssdeep_matches if ssdeep_matches else 'Not available',
        'TLSH': tlsh_matches if tlsh_matches else 'Not available',
        'Malware Type': malware_type,
        'Tags': list(set(tags))  # Remove duplicates
    }

    return metadata
